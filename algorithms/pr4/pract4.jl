include("c:\\Users\\elaza\\Desktop\\mirea_progs\\2 sem\\algorithms\\2d week\\pr2\\Pract2.jl")
using LinearAlgebra

#1 Функция, вычисляющая n-ю частичную сумму ряда Тейлора (Маклорена)
# для функции exp(x) при произвольном значении x.
# Алгоритм работает за O(n).
function exp_partial_sum(x, n)
    partial_sum = 0.0
    term = 1.0
    for i in 0:n
        partial_sum += term # Добавляем текущий член ряда к частичной сумме
        term *= x / (i + 1) # Обновляем значение члена ряда для следующей итерации
    end
    return partial_sum
end


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#2 Функция, вычисляющая exp(x) с максимально возможной точностью для
# арифметики с плавающей точкой.
function exp(x)
    e = convert(Float64, MathConstants.e)
    int_x = trunc(x) # Целая часть x
    frac_x = x - int_x # Дробная часть x
    exp_int_x = power(e, int_x) # e^int(x)
    exp_frac_x = exp_partial_sum(frac_x, trunc(-log10(eps()))) # Вычисляем частичную сумму для дробной части x
    return exp_int_x * exp_frac_x # Возвращаем итоговый результат
end


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#3 Вычисление функции Бесселя первого рода порядка n по ее ряду Тейлора
function bessel(n, x)
    fac1 = big(1)  # факториалы будут большими числами, поэтому используем big
    fac2 = big(factorial(n))  # факториал известного значения n
    sgn = 1  # знак в каждой сумме начинается с 1
    j = big((sgn * (x/2)^(n)) / (fac1 * fac2))  # первый элемент суммы (k = 0)

    # Цикл для вычисления суммы
    for k in 1:100
        fac1 = fac1 * k  # k!
        fac2 = fac2 * (k+n)  # (k + n)!
        sgn = -sgn  # смена знака на каждой итерации
        j += big((sgn * power(x/2, 2k+n)) / (fac1 * fac2))  # добавление элемента в сумму
    end

    return j
end

# Проверка по графику
using Plots

function draw()
    x = -20:0.01:20
    p = plot()
    xlabel!("x")
    ylabel!("J_n(x)")
    title!("Bessel Functions")
    for n in 0:4
        plot!(p, x, bessel.(n, x), label="Порядок $n")
    end
    xlims!(-20, 20)  # установка масштаба по оси x
    ylims!(-0.6, 1.1)  # установка масштаба по оси y
    display(p)
    println("done")
end

#draw()


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#4 Алгорим, реализующий обратный ход алгоритма Жордана-Гаусса
function backward_substitution(U, b)
    # U: верхнетреугольная матрица
    # b: вектор правой части

    n = size(U, 1)
    x = zeros(n)  # вектор неизвестных

    # обратный ход алгоритма Жордана-Гаусса
    for i = n:-1:1
        s = dot(U[i, i+1:end], x[i+1:end]) # быстрый вариант написания скалярного произведения
        x[i] = (b[i] - s) / U[i, i]
    end

    return x
end


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#5 Алгоритм, осуществляющий приведение матрицы матрицы кступенчатому виду
function forward_substitution(A)
    m, n = size(A)
    r = 1
    for j in 1:n
        if r == n
            break
        end
        # Находим главный элемент в j-том столбце
        i_max = argmax(abs.(A[r:m, j])) + r - 1
        
        if A[i_max, j] != 0
            # Меняем местами строки, чтобы главный элемент был на диагонали
            A[r, :], A[i_max, :] = A[i_max, :], A[r, :]
            # Делаем главный элемент равным 1, деля строку на него
            A[r, :] /= A[r, j]
            # Обнуляем все элементы под главным элементом в столбце
            for i in r+1:m
                A[i, j:end] -= A[i, j] * A[r, j:end]
            end
            r += 1
        end
    end
    return A
end


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#6 Алгоритм, реализующий метод Жордана-Гаусса решение СЛАУ для произвольной невырожденной матрицы (достаточно хорошо обусловленной).
function gauss_jordan(A, b)
    # A: матрица коэффициентов
    # b: вектор правой части

    # приводим матрицу A к ступенчатому виду
    A = forward_substitution([A b])

    # извлекаем матрицу U из ступенчатой матрицы
    U = A[:, 1:end-1]

    # извлекаем вектор правой части из ступенчатой матрицы
    b = A[:, end]

    # решаем систему методом обратного хода алгоритма Жордана-Гаусса
    return backward_substitution(U, b)
end

# Проверка
A = [1 2 3 4;
     2 1 2 3;
     3 2 1 2;
     4 3 2 1]
b = [5; 1; 1; -5.0]
println(gauss_jordan(A, b))


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#7 Проведение временных замеров с помощью макроса @time для систем большого размера (порядка 1000)

# генерируем случайную матрицу и вектор
n = 1000
A = randn(n, n)
b = randn(n)

println("Обусловленность матрицы: $(cond(A))")
# решаем СЛАУ и замеряем время
print("Время выполнения:")
@time x = gauss_jordan(A, b)
println("Отклонение от верного решения: $(norm(A*x - b))")


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#8 Функция, возвращающая ранг произвольной прямоугольной матрицы
function matrix_rank(A)
    # приводим матрицу A к ступенчатому виду
    A = forward_substitution(A)
    # считаем количество ненулевых строк в ступенчатой матрице
    rank = 0
    for i in 1:size(A, 1)
        if any(x -> Bool(x), A[i, :])
            rank += 1
        else
            break
        end
    end
    return rank
end

# Проверка
A = [0.5 0 -1; 1 0 2; 2.3 0 17]
println("rank(A) = $(matrix_rank(A))")


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#9 Функция, возвращающая определитель произвольной квадратной матрицы
function matrix_det(A)
    # приводим матрицу A к ступенчатому виду
    A = forward_substitution(A)
    # считаем произведение элементов на главной диагонали
    return prod(A[i, i] for i in 1:size(A, 1))
end

# Проверка
A = [0.5 0 -1; 1 0 2; 2.3 0 17]
println("det(A) = $(matrix_det(A))")